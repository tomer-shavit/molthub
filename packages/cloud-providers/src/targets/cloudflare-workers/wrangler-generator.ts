/**
 * Wrangler configuration generator for Cloudflare Workers deployment.
 *
 * Generates:
 * - wrangler.jsonc — Cloudflare Workers project configuration
 * - Dockerfile — Container image for the Moltbot gateway sandbox
 * - start-moltbot.sh — Startup script inside the container
 */

import { CloudflareWorkersConfig } from "../../interface/deployment-target";

/** Default Moltbot container image */
const DEFAULT_IMAGE = "ghcr.io/clawdbot/clawdbot:latest";

/** Default sandbox instance type */
const DEFAULT_SANDBOX_INSTANCE_TYPE = "standard-4";

/**
 * Generated wrangler configuration output.
 */
export interface WranglerConfigOutput {
  /** wrangler.jsonc content as a string */
  wranglerJsonc: string;
  /** Dockerfile content */
  dockerfile: string;
  /** start-moltbot.sh startup script */
  startScript: string;
}

/**
 * Generates all configuration files needed for a Cloudflare Workers
 * deployment of Moltbot.
 *
 * @param config - Cloudflare Workers deployment config
 * @param workerVars - Plain-text variables for the [vars] section
 * @returns Generated configuration files
 */
export function generateWranglerConfig(
  config: CloudflareWorkersConfig,
  workerVars: Record<string, string>
): WranglerConfigOutput {
  return {
    wranglerJsonc: generateWranglerJsonc(config, workerVars),
    dockerfile: generateDockerfile(config),
    startScript: generateStartScript(config),
  };
}

/**
 * Generates the wrangler.jsonc configuration file content.
 *
 * The configuration includes:
 * - Worker name and account ID
 * - Compatibility settings
 * - R2 bucket binding (if configured)
 * - Container/sandbox settings
 * - Plain-text vars (secrets are set separately via `wrangler secret`)
 */
function generateWranglerJsonc(
  config: CloudflareWorkersConfig,
  workerVars: Record<string, string>
): string {
  const sandboxType = config.sandboxInstanceType || DEFAULT_SANDBOX_INSTANCE_TYPE;

  const wranglerConfig: Record<string, unknown> = {
    name: config.workerName,
    account_id: config.accountId,
    main: "src/index.ts",
    compatibility_date: "2024-12-01",
    compatibility_flags: ["nodejs_compat"],
    // Container / sandbox configuration for Moltbot
    containers: {
      instances: [
        {
          name: "moltbot-gateway",
          image: `./Dockerfile`,
          instance_type: sandboxType,
          port: config.gatewayPort,
          max_instances: 1,
        },
      ],
    },
  };

  // R2 bucket binding for state persistence
  if (config.r2BucketName) {
    wranglerConfig.r2_buckets = [
      {
        binding: "STATE_BUCKET",
        bucket_name: config.r2BucketName,
      },
    ];
  }

  // Plain-text vars (non-secret environment variables)
  if (Object.keys(workerVars).length > 0) {
    wranglerConfig.vars = workerVars;
  }

  // Custom domain route
  if (config.customDomain) {
    wranglerConfig.routes = [
      {
        pattern: config.customDomain,
        custom_domain: true,
      },
    ];
  }

  // Use JSON.stringify with indentation, then add a JSONC header comment
  const jsonBody = JSON.stringify(wranglerConfig, null, 2);

  return [
    "// Wrangler configuration for Moltbot gateway on Cloudflare Workers",
    "// Generated by Molthub — do not edit manually",
    "//",
    `// Worker: ${config.workerName}`,
    `// Account: ${config.accountId}`,
    jsonBody,
  ].join("\n");
}

/**
 * Generates a Dockerfile for the Moltbot gateway container
 * that runs inside the Cloudflare Sandbox.
 */
function generateDockerfile(config: CloudflareWorkersConfig): string {
  const lines = [
    `FROM ${DEFAULT_IMAGE}`,
    "",
    "# Create directories for config and state",
    "RUN mkdir -p /app/config /app/state",
    "",
    "# Copy startup script",
    "COPY start-moltbot.sh /app/start-moltbot.sh",
    "RUN chmod +x /app/start-moltbot.sh",
    "",
    "# Set environment defaults",
    `ENV MOLTBOT_GATEWAY_PORT=${config.gatewayPort}`,
    'ENV CLAWDBOT_CONFIG_PATH="/app/config/moltbot.json"',
    'ENV CLAWDBOT_STATE_DIR="/app/state"',
    "",
    `EXPOSE ${config.gatewayPort}`,
    "",
    'ENTRYPOINT ["/app/start-moltbot.sh"]',
  ];

  return lines.join("\n");
}

/**
 * Generates the start-moltbot.sh startup script that runs inside the container.
 *
 * The script:
 * 1. Writes the moltbot.json config from environment if provided
 * 2. Starts the Moltbot gateway with the configured port
 * 3. Handles graceful shutdown via SIGTERM
 */
function generateStartScript(config: CloudflareWorkersConfig): string {
  const lines = [
    "#!/bin/bash",
    "set -euo pipefail",
    "",
    '# Startup script for Moltbot gateway in Cloudflare Workers Sandbox',
    "# Generated by Molthub",
    "",
    '# Ensure state directory exists',
    "mkdir -p /app/state",
    "",
    "# If MOLTBOT_CONFIG_JSON is set, write it to the config file",
    'if [ -n "${MOLTBOT_CONFIG_JSON:-}" ]; then',
    '  echo "$MOLTBOT_CONFIG_JSON" > /app/config/moltbot.json',
    '  echo "Wrote moltbot.json from MOLTBOT_CONFIG_JSON env var"',
    "fi",
    "",
    "# Trap SIGTERM for graceful shutdown",
    "trap 'echo \"Received SIGTERM, shutting down...\"; kill -TERM \"$PID\"; wait \"$PID\"' TERM",
    "",
    "# Start the Moltbot gateway",
    `echo "Starting Moltbot gateway on port ${config.gatewayPort}"`,
    `moltbot gateway --port ${config.gatewayPort} &`,
    "PID=$!",
    "",
    "# Wait for the gateway process",
    "wait $PID",
  ];

  return lines.join("\n");
}

/**
 * Returns the default worker entry point source code (src/index.ts).
 *
 * This is a minimal Cloudflare Worker that proxies requests to the
 * Moltbot gateway container and optionally handles R2 state sync.
 */
export function generateWorkerEntryPoint(config: CloudflareWorkersConfig): string {
  const hasR2 = !!config.r2BucketName;

  const lines = [
    "// Moltbot Gateway Worker — auto-generated by Molthub",
    "// Proxies incoming requests to the Moltbot Sandbox container.",
    "",
    "export default {",
    "  async fetch(request: Request, env: Record<string, unknown>): Promise<Response> {",
    `    const gatewayPort = env.GATEWAY_PORT || ${config.gatewayPort};`,
    "    const url = new URL(request.url);",
    "    const containerUrl = `http://localhost:${gatewayPort}${url.pathname}${url.search}`;",
    "",
    "    try {",
    "      const response = await fetch(containerUrl, {",
    "        method: request.method,",
    "        headers: request.headers,",
    "        body: request.body,",
    "      });",
    "      return new Response(response.body, {",
    "        status: response.status,",
    "        statusText: response.statusText,",
    "        headers: response.headers,",
    "      });",
    "    } catch (err) {",
    "      return new Response(",
    '        JSON.stringify({ error: "Gateway unavailable", details: String(err) }),',
    "        { status: 502, headers: { \"Content-Type\": \"application/json\" } }",
    "      );",
    "    }",
    "  },",
  ];

  if (hasR2) {
    lines.push(
      "",
      "  // Scheduled handler for R2 state backup (runs every 5 minutes)",
      "  async scheduled(event: ScheduledEvent, env: Record<string, unknown>): Promise<void> {",
      "    // State backup is handled by the r2-state-sync module",
      '    console.log("Scheduled state backup triggered at", new Date(event.scheduledTime).toISOString());',
      "  },",
    );
  }

  lines.push("};", "");

  return lines.join("\n");
}
